"""Financial data aggregation utility.

This script reads raw consolidated financial statement and financial ratio CSV
files from `data/raw`, extracts and renames a curated set of variables from
each, merges them, and saves the resulting wide-form dataframe to
`data/processed/financial_ratios.csv`.

This approach, favoring pre-calculated ratios when available, is more robust
to missing individual account lines in the primary statement files.

Author: Auto-generated by Cascade AI assistant
"""
from __future__ import annotations

from pathlib import Path
from typing import Dict, List

import pandas as pd

# ---------------------------------------------------------------------------
# Configuration constants
# ---------------------------------------------------------------------------
RAW_DIR = Path("data/raw")
OUTPUT_PATH = Path("data/processed/financial_ratios.csv")
ID_COLS = ["회사명", "거래소코드", "회계년도"]

# --- Column Mappings ---
# Define the columns we want to extract and their desired English names.

# 1. For consolidated statements (연결재무제표)
CONSOLIDATED_ACCOUNT_CODE_MAP = {
    # "sales" is not available in the provided consolidated statements file.
    "operating_income": "[B420000000]* (정상)영업손익(보고서기재)(IFRS연결)(천원)",
    "net_income": "[B840000000]당기순이익(손실)(IFRS연결)(천원)",
    "total_assets": "[A100000000]자산(*)(IFRS연결)(천원)",
    "total_liabilities": "[A800000000]부채(*)(IFRS연결)(천원)",
    "total_equity": "[A600000000]자본(*)(IFRS연결)(천원)",
}

# 2. For non-consolidated statements (재무제표)
NON_CONSOLIDATED_ACCOUNT_CODE_MAP = {
    # "sales" is not available in the provided non-consolidated statements file.
    "operating_income": "[B420000000]* (정상)영업손익(보고서기재)(IFRS)(천원)",
    "net_income": "[B840000000]당기순이익(손실)(IFRS)(천원)",
    "total_assets": "[A100000000]자산(*)(IFRS)(천원)",
    "total_liabilities": "[A800000000]부채(*)(IFRS)(천원)",
    "total_equity": "[A600000000]자본(*)(IFRS)(천원)",
}

# 3. For consolidated financial ratios (연결재무비율)
CONSOLIDATED_RATIO_COLUMN_MAP = {
    # "current_ratio" is not available in the provided consolidated ratios file.
    "debt_to_equity": "부채비율(IFRS연결)",
    "roe": "자기자본순이익률(IFRS연결)",
    "roa": "총자본순이익률(IFRS연결)",
    "net_profit_margin": "매출액순이익률(IFRS연결)",
    "operating_profit_margin": "매출액정상영업이익률(IFRS연결)",
    "eps": "1주당순이익(IFRS연결)(원)",
    "bps": "1주당순자산(IFRS연결)(원)",
    # "per" and "pbr" are not available in the provided consolidated ratios file.
}

# 4. For non-consolidated financial ratios (재무비율)
NON_CONSOLIDATED_RATIO_COLUMN_MAP = {
    # "current_ratio" is not available in the provided non-consolidated ratios file.
    "debt_to_equity": "부채비율(IFRS)",
    "roe": "자기자본순이익률(IFRS)",
    "roa": "총자본순이익률(IFRS)",
    "net_profit_margin": "매출액순이익률(IFRS)",
    "operating_profit_margin": "매출액정상영업이익률(IFRS)",
    "eps": "1주당순이익(IFRS)(원)",
    "bps": "1주당순자산(IFRS)(원)",
    "per": "PER(최고)(IFRS)",
    "pbr": "PBR(최고)(IFRS)",
}


# ---------------------------------------------------------------------------
# Data Loading and Processing Helpers
# ---------------------------------------------------------------------------

def _find_and_load_csv(filename: str) -> pd.DataFrame:
    """Construct path to a CSV in RAW_DIR, check existence, and load it."""
    # Use glob to find the file, as the exact name can vary slightly.
    # This is more robust than a fixed filename.
    try:
        file_path = next(RAW_DIR.glob(filename))
    except StopIteration:
        raise FileNotFoundError(f"Could not find required file matching: {filename}")
    print(f"Loading data from {file_path.name}...")
    return pd.read_csv(file_path)


def _extract_and_rename(
    df: pd.DataFrame, column_map: Dict[str, str], is_code_map: bool
) -> pd.DataFrame:
    """Extract and rename columns from a dataframe based on a mapping."""
    rename_dict = {}
    for eng_name, raw_name in column_map.items():
        if is_code_map:
            # Find column by exact name, since we now have the full name
            if raw_name in df.columns:
                rename_dict[raw_name] = eng_name
            else:
                print(f"⚠️  Code '{raw_name}' not found; '{eng_name}' will be missing.")
        else:
            # Find column by exact name
            if raw_name in df.columns:
                rename_dict[raw_name] = eng_name
            else:
                print(f"⚠️  Column '{raw_name}' not found; '{eng_name}' will be missing.")

    # Subset to ID columns and the columns we found
    found_cols = list(rename_dict.keys())
    # Handle cases where no columns are found
    if not found_cols:
        return pd.DataFrame(index=df.set_index(ID_COLS).index)

    sub_df = df[ID_COLS + found_cols].copy()
    sub_df = sub_df.rename(columns=rename_dict)

    # Ensure all extracted columns are numeric
    num_cols = [c for c in sub_df.columns if c not in ID_COLS]
    sub_df[num_cols] = sub_df[num_cols].apply(pd.to_numeric, errors="coerce")

    return sub_df.set_index(ID_COLS)


# ---------------------------------------------------------------------------
# Public API – Main Orchestration
# ---------------------------------------------------------------------------

def _load_and_process_data(
    statement_filename: str,
    ratio_filename: str,
    account_code_map: Dict[str, str],
    ratio_column_map: Dict[str, str],
) -> pd.DataFrame:
    """Load, process, and merge a corresponding pair of statement and ratio files."""
    # Load base financial statement data
    statement_df_raw = _find_and_load_csv(statement_filename)
    base_vars_df = _extract_and_rename(
        statement_df_raw, account_code_map, is_code_map=True
    )

    # Load pre-calculated financial ratios
    ratio_df_raw = _find_and_load_csv(ratio_filename)
    ratios_df = _extract_and_rename(
        ratio_df_raw, ratio_column_map, is_code_map=False
    )

    # Merge into a single dataframe
    return pd.merge(
        base_vars_df,
        ratios_df,
        left_index=True,
        right_index=True,
        how="outer",
    )


def build_financial_data_dataframe(save: bool = True) -> pd.DataFrame:
    """Load, process, and merge financial data, then optionally save to disk."""
    # 1. Load and process consolidated data
    print("--- Processing Consolidated (연결) Data ---")
    consolidated_df = _load_and_process_data(
        statement_filename="연결 재무제표(IFRS).csv",
        ratio_filename="연결 재무비율(IFRS).csv",
        account_code_map=CONSOLIDATED_ACCOUNT_CODE_MAP,
        ratio_column_map=CONSOLIDATED_RATIO_COLUMN_MAP,
    )

    # 2. Load and process non-consolidated (separate) data
    print("\n--- Processing Non-Consolidated (별도) Data ---")
    separate_df = _load_and_process_data(
        statement_filename="재무제표(IFRS).csv",
        ratio_filename="재무비율(IFRS).csv",
        account_code_map=NON_CONSOLIDATED_ACCOUNT_CODE_MAP,
        ratio_column_map=NON_CONSOLIDATED_RATIO_COLUMN_MAP,
    )

    # 3. Combine datasets: use consolidated first, fill NaNs with separate data
    print("\nCombining datasets (consolidated fills from non-consolidated)...")
    # The index must be aligned for combine_first to work correctly
    final_df = consolidated_df.combine_first(separate_df)

    if save:
        OUTPUT_PATH.parent.mkdir(parents=True, exist_ok=True)
        final_df.reset_index().to_csv(OUTPUT_PATH, index=False)
        print(f"\n✅ Saved combined financial data to: {OUTPUT_PATH}")

    return final_df


if __name__ == "__main__":
    # Running the module directly creates/refreshes the output file.
    build_financial_data_dataframe()
